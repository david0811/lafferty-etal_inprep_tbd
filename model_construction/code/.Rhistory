plot_gamma(shape = 1, rate = 0.0008) +
labs(x = "sigma", y = "pdf")
plot_gamma(shape = 1, rate = 0.1) +
labs(x = "sigma", y = "pdf")
plot_gamma(shape = 1, rate = 0.01) +
labs(x = "sigma", y = "pdf")
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs,
family = gaussian,
# prior_intercept = normal(0, 1000, autoscale = TRUE),
# prior = normal(100, 100, autoscale = TRUE),
# prior_aux = exponential(0.01, autoscale = TRUE),
chains = 4, iter = 5000*2,
cores = 3, seed = 84735)
prior_summary(GDD_model)
# Effective sample size ratio and Rhat
neff_ratio(GDD_model)
rhat(GDD_model)
# Trace & density plots of parallel chains
mcmc_trace(GDD_model, size = 0.1)
mcmc_dens_overlay(GDD_model)
# Summarize posterior
tidy(GDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs, size = 0.1) +
scale_fill_brewer()
# Posterior predictive check
pp_check(GDD_model, nreps = 50) +
xlab("County GDD") +
theme_grey()
# Posterior predictive check
pp_check(GDD_model, nreps = 100) +
xlab("County GDD") +
theme_grey()
prior_summary(GDD_model)
mcmc_dens_overlay(GDD_model)
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs,
family = gaussian,
# prior_intercept = normal(0, 1000, autoscale = TRUE),
# prior = normal(100, 100, autoscale = TRUE),
# prior_aux = exponential(0.01, autoscale = TRUE),
chains = 3, iter = 10000*2,
cores = 3, seed = 84735)
# Effective sample size ratio and Rhat
neff_ratio(GDD_model)
rhat(GDD_model)
# Trace & density plots of parallel chains
mcmc_trace(GDD_model, size = 0.1)
mcmc_dens_overlay(GDD_model)
# Summarize posterior
tidy(GDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs, size = 0.1) +
scale_fill_brewer()
# Posterior predictive check
pp_check(GDD_model, nreps = 100) +
xlab("County GDD") +
theme_grey()
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs,
family = gaussian,
prior_intercept = normal(-1000, 100),
prior = normal(150, 100),
prior_aux = exponential(0.0008),
chains = 3, iter = 10000*2,
cores = 3, seed = 84735)
prior_summary(GDD_model)
# Effective sample size ratio and Rhat
neff_ratio(GDD_model)
rhat(GDD_model)
# Trace & density plots of parallel chains
mcmc_trace(GDD_model, size = 0.1)
mcmc_dens_overlay(GDD_model)
# Summarize posterior
tidy(GDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
##################################################
# County GDD
##################################################
# Visualize data
ggplot(df_county_obs, aes(x = tavg, y = GDD)) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
df_county_obs
library(tidyverse)
library(rstan)
library(rstanarm)
library(bayesplot)
library(tidybayes)
library(broom.mixed)
library(modelr)
library(bayesrules)
##################################################
# Read all relevant data
##################################################
df_county_obs <- read_csv('../input_data/gridmet_county_weather_variables_1979-2020.csv')
df_mw_obs <- read_csv('../input_data/gmfd_midwest_tavg_1948-2016.csv')
# OLS model
GDD_model_freq <- lm(GDD ~ tavg, data = df_county_obs)
GDD_model_freq
summary(GDD_model_freq)
##################################################
# County GDD
##################################################
# Visualize data
ggplot(df_county_obs, aes(x = tavg, y = GDD)) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
df_county_obs_2000 <- filter(df_county_obs,
year > 2000)
df_county_obs_2000
# Visualize data
ggplot(df_county_obs_2000, aes(x = tavg, y = GDD)) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# OLS model
GDD_model_freq <- lm(GDD ~ tavg, data = df_county_obs)
# OLS model
GDD_model_freq <- lm(GDD ~ tavg, data = df_county_obs_2000)
summary(GDD_model_freq)
df_county_obs_2000 <- filter(df_county_obs,
year > 2010)
# Visualize data
ggplot(df_county_obs_2000, aes(x = tavg, y = GDD)) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# OLS model
GDD_model_freq <- lm(GDD ~ tavg, data = df_county_obs_2000)
summary(GDD_model_freq)
View(df_county_obs)
View(df_mw_obs)
df_county_obs_2000 <- filter(df_county_obs,
year > 2015)
# Visualize data
ggplot(df_county_obs_2000, aes(x = tavg, y = GDD)) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# OLS model
GDD_model_freq <- lm(GDD ~ tavg, data = df_county_obs_2000)
summary(GDD_model_freq)
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs_2000,
family = gaussian,
prior_intercept = normal(-1000, 100),
prior = normal(150, 100),
prior_aux = exponential(0.0008),
chains = 3, iter = 10000*2,
cores = 3, seed = 84735)
prior_summary(GDD_model)
# Effective sample size ratio and Rhat
neff_ratio(GDD_model)
rhat(GDD_model)
# Trace & density plots of parallel chains
mcmc_trace(GDD_model, size = 0.1)
mcmc_dens_overlay(GDD_model)
# Summarize posterior
tidy(GDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_2000 %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_200, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_2000 %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_2000, size = 0.1) +
scale_fill_brewer()
df_county_obs$state <- df_county_obs$fips %>% substr(1,3)
df_county_obs
df_county_obs$state <- df_county_obs$fips %>% substr(1,2)
df_county_obs_mw <- filter(df_county_obs, state %in% c('17','19','29')) # IL, IA, MO
df_county_obs_mw
df_county_obs_2000
##################################################
# County GDD
##################################################
# Visualize data
ggplot(df_county_obs_mw, aes(x = tavg, y = GDD)) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# OLS model
GDD_model_freq <- lm(GDD ~ tavg, data = df_county_obs_mw)
summary(GDD_model_freq)
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs_mw,
family = gaussian,
prior_intercept = normal(-1000, 100),
prior = normal(150, 100),
prior_aux = exponential(0.0008),
chains = 3, iter = 10000*2,
cores = 3, seed = 84735)
prior_summary(GDD_model)
# Effective sample size ratio and Rhat
neff_ratio(GDD_model)
rhat(GDD_model)
# Trace & density plots of parallel chains
mcmc_trace(GDD_model, size = 0.1)
mcmc_dens_overlay(GDD_model)
# Summarize posterior
tidy(GDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Posterior predictive check
pp_check(GDD_model, nreps = 100) +
xlab("County GDD") +
theme_grey()
##################################################
# County EDD
##################################################
# Visualize data
ggplot(df_county_obs_mw, aes(x = tavg, y = log(EDD))) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs_mw,
family = student_t,
# prior_intercept = normal(-1000, 100),
# prior = normal(150, 100),
# prior_aux = exponential(0.0008),
chains = 3, iter = 10000*2,
cores = 3, seed = 84735)
# Bayesian model
GDD_model <- stan_glm(GDD ~ tavg, data = df_county_obs_mw,
family = gaussian,
# prior_intercept = normal(-1000, 100),
# prior = normal(150, 100),
# prior_aux = exponential(0.0008),
chains = 3, iter = 10000*2,
cores = 3, seed = 84735)
prior_summary(GDD_model)
# Effective sample size ratio and Rhat
neff_ratio(GDD_model)
rhat(GDD_model)
# Trace & density plots of parallel chains
mcmc_trace(GDD_model, size = 0.1)
mcmc_dens_overlay(GDD_model)
# Summarize posterior
tidy(GDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(GDD_model) %>%
ggplot(aes(x = tavg, y = GDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Posterior predictive check
pp_check(GDD_model, nreps = 100) +
xlab("County GDD") +
theme_grey()
##################################################
# County EDD
##################################################
# Visualize data
ggplot(df_county_obs_mw, aes(x = tavg, y = log(EDD))) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# Bayesian model
EDD_model <- stan_glm(EDD ~ tavg, data = df_county_obs_mw,
family = gaussian(link='log'),
prior_intercept = normal(0, 100),
prior = normal(0, 10),
prior_aux = exponential(0.0008),
chains = 3, iter = 5000*2,
cores = 3, seed = 84735)
# Effective sample size ratio and Rhat
neff_ratio(EDD_model)
rhat(EDD_model)
# Trace & density plots of parallel chains
mcmc_trace(EDD_model, size = 0.1)
mcmc_dens_overlay(EDD_model)
# Summarize posterior
tidy(EDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model) %>%
ggplot(aes(x = tavg, y = EDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model) %>%
ggplot(aes(x = tavg, y = log(EDD))) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model) %>%
ggplot(aes(x = tavg, y = EDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Bayesian model
EDD_model <- stan_glm(log(EDD) ~ tavg, data = df_county_obs_mw,
family = gaussian(),
prior_intercept = normal(0, 100),
prior = normal(0, 10),
prior_aux = exponential(0.0008),
chains = 3, iter = 5000*2,
cores = 3, seed = 84735)
# Effective sample size ratio and Rhat
neff_ratio(EDD_model)
rhat(EDD_model)
# Trace & density plots of parallel chains
mcmc_trace(EDD_model, size = 0.1)
mcmc_dens_overlay(EDD_model)
# Summarize posterior
tidy(EDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model) %>%
ggplot(aes(x = tavg, y = log(EDD))) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model) %>%
ggplot(aes(x = tavg, y = logEDD)) +
stat_lineribbon(aes(y = log(.prediction)), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model) %>%
ggplot(aes(x = tavg, y = EDD)) +
stat_lineribbon(aes(y = log(.prediction)), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
add_predicted_draws(EDD_model)
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model, tranform=TRUE) %>%
ggplot(aes(x = tavg, y = EDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Bayesian model
EDD_model <- stan_glm(EDD ~ tavg, data = df_county_obs_mw,
family = gaussian(link='log'),
# prior_intercept = normal(0, 100),
# prior = normal(0, 10),
# prior_aux = exponential(0.0008),
chains = 3, iter = 5000*2,
cores = 3, seed = 84735)
# Bayesian model
EDD_model <- stan_glm(EDD ~ tavg, data = df_county_obs_mw,
family = gaussian(link='log'),
prior_intercept = normal(0, 100),
prior = normal(0, 100),
prior_aux = exponential(0.0008),
chains = 3, iter = 5000*2,
cores = 3, seed = 84735)
library(tidyverse)
library(rstan)
library(rstanarm)
library(bayesplot)
library(tidybayes)
library(broom.mixed)
library(modelr)
library(bayesrules)
# gridmet county obs
df_county_obs <- read_csv('../input_data/gridmet_county_weather_variables_1979-2020.csv')
df_county_obs$state <- df_county_obs$fips %>% substr(1,2) # add state column
df_county_obs_mw <- filter(df_county_obs, state %in% c('17','19','29')) # IL, IA, MO
##################################################
# County EDD
##################################################
# Visualize data
ggplot(df_county_obs_mw, aes(x = tavg, y = log(EDD))) +
geom_point(size = 0.5) +
geom_smooth(method = "lm", se = FALSE)
# Bayesian model
EDD_model <- stan_glm(EDD ~ tavg, data = df_county_obs_mw,
family = gaussian(link='log'),
prior_intercept = normal(0, 100),
prior = normal(0, 100),
prior_aux = exponential(0.0008),
chains = 3, iter = 5000*2,
cores = 3, seed = 84735)
# Bayesian model
EDD_model <- stan_glm(log(EDD) ~ tavg, data = df_county_obs_mw,
family = gaussian(),
prior_intercept = normal(0, 100),
prior = normal(0, 100),
prior_aux = exponential(0.0008),
chains = 3, iter = 5000*2,
cores = 3, seed = 84735)
prior_summary(EDD_model)
# Effective sample size ratio and Rhat
neff_ratio(EDD_model)
rhat(EDD_model)
# Trace & density plots of parallel chains
mcmc_trace(EDD_model, size = 0.1)
mcmc_dens_overlay(EDD_model)
# Summarize posterior
tidy(EDD_model, effects = c("fixed", "aux"),
conf.int = TRUE, conf.level = 0.99)
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model, tranform=TRUE) %>%
ggplot(aes(x = tavg, y = EDD)) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model, tranform=TRUE) %>%
ggplot(aes(x = tavg, y = log(EDD))) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
# Posterior predictive check
pp_check(EDD_model, nreps = 50) +
xlab("County EDD") +
theme_grey()
# Plot predictive
df_county_obs_mw %>%
data_grid(tavg = seq_range(tavg, n = 101)) %>%
add_predicted_draws(EDD_model, tranform=TRUE) %>%
ggplot(aes(x = tavg, y = log(EDD))) +
stat_lineribbon(aes(y = .prediction), .width = c(.99, .95, .8, .5), color = "#08519C") +
geom_point(data = df_county_obs_mw, size = 0.1) +
scale_fill_brewer()
library(tidyverse)
library(rstan)
library(rstanarm)
library(bayesplot)
library(tidybayes)
library(broom.mixed)
library(modelr)
library(bayesrules)
library(tidyverse)
library(rstan)
library(rstanarm)
library(bayesplot)
library(tidybayes)
library(broom.mixed)
library(modelr)
library(bayesrules)
# gridmet state obs
df_state_obs_maize <- read_csv('../input_data/gridmet_state_weather_variables_maize_irr_weighted.csv')
df_state_obs_soy <- read_csv('../input_data/gridmet_state_weather_variables_soy_irr_weighted.csv')
# USDA water applied
df_water_applied_maize <- read_csv('../input_data/usda_maize_water_applied_2013-2018.csv')
df_water_applied_soy <- read_csv('../input_data/usda_soy_water_applied_2013-2018.csv')
View(df_water_applied_maize)
df_maize <- inner_join(df_state_obs_maize, df_water_applied_maize)
View(df_state_obs_maize)
View(df_water_applied_maize)
df_maize <- inner_join(df_state_obs_maize, df_water_applied_maize,
by.x=c('year', 'state'),
by.x=c('year', 'state_fips_code'))
df_maize <- inner_join(df_state_obs_maize, df_water_applied_maize,
by.x=c('year', 'state'),
by.y=c('year', 'state_fips_code'))
View(df_state_obs_maize)
View(df_water_applied_maize)
df_maize <- inner_join(df_state_obs_maize, df_water_applied_maize,
by=c('year', 'state' = 'state_fips_code'))
View(df_maize)
df_state_obs_maize
df_water_applied_maize
